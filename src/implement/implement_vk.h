/**
This header was generated by `rhi_gen` (https://github.com/Tomicyo/rhi_gen)
Copyright (c) 2017 Tsin Studio

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
**/
#include <common/common.h>
#include "sappheiros.h"
#define VK_USE_PLATFORM_WIN32_KHR
#include <vulkan/vulkan.h>
#include <vector>
namespace vulkan
{

template <typename T, typename Interface>
class TObj : public Interface
{
public:

  TObj()
    : InternalCount(1)
    , ExternalCount(1)
    , Handle(nullptr)
  {
  }

  virtual ~TObj() {}

  uint32_t AddRef() override
  {
    _InterlockedIncrement(&InternalCount);
    _InterlockedIncrement(&ExternalCount);
    return InternalCount;
  }

  uint32_t Release() override
  {
    _InterlockedDecrement(&InternalCount);
    _InterlockedDecrement(&ExternalCount);
    int refCount = InternalCount;
    if (InternalCount == 0)
    {
      delete this; // will free ref counter
    }
    return refCount;
  }

  T GetHandle() const { return Handle; }

private:
  uint32_t InternalCount;
  uint32_t ExternalCount;
protected:
  T Handle;
};

class FactoryImpl : public TObj<VkInstance, ISPHFactory>
{
public:
  using This = TObj<VkInstance, ISPHFactory>;
  sphResult EnumDevice(uint32_t * count, ISPHDevice ** ppDevice) override;
  sphResult CreateSwapchain(const sphSwapChainDesc * desc, ISPHCommandQueue * pCommandQueue, void * pWindow, ISPHSwapChain ** pSwapchain) override;
private:
  friend class SwapChainImpl;
  friend API ISPHFactory * CreateFactory();
  FactoryImpl();
  ~FactoryImpl();
};

class CommandQueueImpl;
class SwapChainImpl : public TObj<VkSwapchainKHR, ISPHSwapChain>
{
public:
  void Present() override;
  sphResult GetTexture(ISPHTexture ** ppTexture, uint32_t index) override;
private:
  friend class FactoryImpl;
  SwapChainImpl(FactoryImpl* impl, const sphSwapChainDesc* desc,
    CommandQueueImpl* pQueue, void* hWnd);
  ~SwapChainImpl();
  FactoryImpl * Impl;
  CommandQueueImpl * QueueImpl;
  VkExtent2D								Extent = {};
  VkSurfaceKHR							Surface = VK_NULL_HANDLE;
  uint32_t									SelectedPresentQueueFamilyIndex = 0;
  uint32_t 									DesiredBackBufferCount;
  uint32_t									ReserveBackBufferCount;
  std::vector<VkImage>			ColorImages;
  VkFormat								  ColorAttachFmt = VK_FORMAT_UNDEFINED;
};

struct GpuAllocation
{
  uint64_t OffSet = 0;
  uint64_t Size = 0;
  bool Transient = false;
  VkDeviceMemory Memory = VK_NULL_HANDLE;
};

class DeviceImpl;
class LinearMemoryAllocator
{
  friend class DeviceImpl;
public:
  GpuAllocation Allocate(VkMemoryAllocateInfo const& AllocaInfo, bool transient);
  void Free(GpuAllocation const& Allocation);
private:
  LinearMemoryAllocator(DeviceImpl * pDevice) : Device(pDevice) {}
  ~LinearMemoryAllocator() {}

  DeviceImpl * Device;
};

class DeviceImpl : public TObj<VkDevice, ISPHDevice>
{
  friend class FactoryImpl;
  friend class SwapChainImpl;
  friend class CommandQueueImpl;
  friend class TextureImpl;
  friend class TextureViewImpl;
  friend class BufferImpl;
  friend class BufferViewImpl;
  friend class PipelineStateImpl;
  friend class LinearMemoryAllocator;
  template <typename VkObj, typename VkResI> friend class TResource;
public:
  using This = TObj<VkDevice, ISPHDevice>;
  void GetDesc(sphDeviceDesc * pDesc) override;
  sphResult CreateCommandQueue(sphCommandQueueType queueType, ISPHCommandQueue ** pQueue) override;
  sphResult CreatePipelineLayout(const sphPipelineLayoutDesc * pPipelineLayoutDesc, ISPHPipelineLayout ** ppPipelineLayout) override;
  sphResult CreateBindingTable(ISPHPipelineLayout * pPipelineLayout, ISPHBindingTable ** ppBindingTable) override;
  sphResult CreatePipelineState(const sphPipelineStateDesc * pPipelineDesc, ISPHPipelineLayout * pPipelineLayout, ISPHPipelineState ** pPipelineState) override;
  sphResult CreateRenderPass(const sphRenderPassDesc * desc, ISPHRenderPass ** ppRenderpass) override;
  sphResult CreateRenderTarget(const sphRenderTargetDesc * desc, ISPHRenderTarget ** ppRenderTarget) override;
  sphResult CreateSampler(const sphSamplerDesc* desc, ISPHSampler ** pSampler) override;
  sphResult CreateBuffer(const sphBufferDesc* desc, ISPHBuffer ** pBuffer) override;
  sphResult CreateBufferView(const sphBufferViewDesc * desc, ISPHBuffer * pBuffer, ISPHBufferView ** pBufView) override;
  sphResult CreateTexture(const sphTextureDesc * desc, ISPHTexture ** pTexture) override;
  sphResult CreateTextureView(const sphTextureViewDesc * desc, ISPHTexture * pTexture, ISPHTextureView ** pTexView) override;
  void WaitIdle() override;

  GpuAllocation Allocate(VkMemoryAllocateInfo const&, bool Transient);
  void Free(GpuAllocation const& Alloca);

  bool FindMemoryHeap(uint32_t typeBits, VkFlags requirementsMask, uint32_t *typeIndex);

private:
  DeviceImpl(FactoryImpl* impl, VkPhysicalDevice Device);
  ~DeviceImpl();
  VkPhysicalDevice PhysicalDevice = VK_NULL_HANDLE;
  VkPhysicalDeviceProperties DeviceProps = {};
  VkPhysicalDeviceMemoryProperties DeviceMemoryProps = {};
  FactoryImpl * Impl = nullptr;
  LinearMemoryAllocator * MemoryAllocator = nullptr;
};

class CommandQueueImpl : public TObj<VkQueue, ISPHCommandQueue>
{
public:
  using This = TObj<VkQueue, ISPHCommandQueue>;
  ISPHCommandBuffer * CommandBuffer() override;
private:
  friend class DeviceImpl;
  friend class SwapChainImpl;
  CommandQueueImpl(DeviceImpl* dev);
  ~CommandQueueImpl();
  DeviceImpl* Device;
};

class CommandBufferImpl : public ISPHCommandBuffer
{
public:
  void Commit() override;
  void Present(ISPHSwapChain * pSwapChain) override;
  void CopyTexture() override;
  void CopyBuffer() override;
  void ClearColorDepth() override;
  void Begin() override;
  void BeginRenderPass(const ISPHRenderPass* pRenderPass) override;
  void SetScissorRects() override;
  void SetViewport(const sphViewport * pViewport) override;
  void SetPipelineState(ISPHPipelineState* pPipelineState) override;
  void SetPipelineLayout(ISPHPipelineLayout * pPipelineLayout) override;
  void SetBindingTable(ISPHBindingTable * pBindingGroup) override;
  void SetIndexBuffer() override;
  void SetVertexBuffer(uint32_t slot, uint64_t offset, ISPHBuffer * pVertexBuffer) override;
  void SetPrimitiveType(sphPrimitiveType primitive) override;
  void DrawInstanced(const sphDrawInstancedDesc * drawParam) override;
  void DrawIndexedInstanced(const sphDrawIndexedInstancedDesc * drawParam) override;
  void EndRenderPass() override;
  void End() override;
  void Dispatch(uint32_t x, uint32_t y, uint32_t z) override;
  void ExecuteBundle() override;
private:
  CommandBufferImpl();
  ~CommandBufferImpl();
};

class PipelineStateImpl : public TObj<VkPipeline, ISPHPipelineState>
{
public:
  using This = TObj<VkPipeline, ISPHPipelineState>;
  sphPipelineType Type() override;
  sphResult GetDesc(sphPipelineStateDesc * desc) override;
private:
  PipelineStateImpl(DeviceImpl* pDevice, const sphPipelineStateDesc* pDesc, ISPHRenderPass* pRenderPass);
  ~PipelineStateImpl();
  union
  {
    VkGraphicsPipelineCreateInfo CachedGraphicsCreateInfo;
    VkComputePipelineCreateInfo CachedComputeCreateInfo;
  };
  DeviceImpl* Device;
};

class PipelineLayoutImpl : public ISPHPipelineLayout
{
public:
private:
  PipelineLayoutImpl();
  ~PipelineLayoutImpl();
};

class BindingGroupImpl : public ISPHBindingTable
{
public:
  void SetSampler(uint32_t index, sphShaderType shaderVis, ISPHSampler * pSampler) override;
  void SetBuffer(uint32_t index, sphShaderType shaderVis, ISPHBufferView * bufferView) override;
  void SetTexture(uint32_t index, sphShaderType shaderVis, ISPHTextureView * textureView) override;
private:
  BindingGroupImpl();
  ~BindingGroupImpl();
};

template <typename VkObj, typename VkResI>
class TResource : public TObj<VkObj, VkResI>
{
public:
  using This = TObj<VkObj, VkResI>;

  TResource(DeviceImpl* pDevice/*, bool transient, GpuAllocation & Alloca*/)
    : This()
    , Device(pDevice)
//    , Transient(transient)
//    , Allocation(Alloca)
  {
    if (Device)
    {
      Device->AddRef();
    }
  }

  virtual ~TResource()
  {
    if (Device)
    {
      if (Allocation.Transient)
      {
        Device->Free(Allocation);
      }
      Device->Release();
    }
  }

  void * Map(uint64_t Start, uint64_t Size) override
  {
    void * Ptr = nullptr;
    vkMapMemory(Device->Handle, Allocation.Memory, 
      Allocation.OffSet + Start, Size, 0, &Ptr);
    return Ptr;
  }

  void UnMap() override
  {
    vkUnmapMemory(Device->Handle, Allocation.Memory);
  }

protected:


  GpuAllocation Allocation;
  DeviceImpl * Device;
};

class BufferImpl : public TResource<VkBuffer, ISPHBuffer>
{
public:
  using This = TResource<VkBuffer, ISPHBuffer>;
  sphResult GetDesc(sphBufferDesc * pDesc) override;
private:
  BufferImpl(DeviceImpl* Device, const sphBufferDesc * pDesc);
  ~BufferImpl();
  sphBufferDesc Desc = {};
  friend class DeviceImpl;
  friend class BufferViewImpl;
};

class TextureImpl : public TResource<VkImage, ISPHTexture>
{
public:
  using This = TResource<VkImage, ISPHTexture>;
  sphResult GetDesc(sphTextureDesc * pDesc) override;
private:
  TextureImpl(DeviceImpl* Device, const sphTextureDesc * pDesc);
  TextureImpl(VkImage SwapchainImg, uint32_t Width, uint32_t Height, sphPixelFormat Format);
  ~TextureImpl() override;
  sphTextureDesc Desc = {};
  VkImageCreateInfo CachedCreateInfo = {};
  friend class DeviceImpl;
  friend class SwapChainImpl;
  friend class TextureViewImpl;
};

class TextureViewImpl : public TObj<VkImageView, ISPHTextureView>
{
public:
  using This = TObj<VkImageView, ISPHTextureView>;
  static VkImageViewCreateInfo ConvertImageViewCreateInfo(const sphTextureViewDesc* pDesc, ISPHTexture * pTexture);
private:
  TextureViewImpl(DeviceImpl* pDevice, const sphTextureViewDesc* pDesc, ISPHTexture * pTexture);
  ~TextureViewImpl();
  friend class DeviceImpl;
  DeviceImpl * Device;
  VkImageViewCreateInfo CachedCreateInfo = {};
};

class SamplerImpl : public ISPHSampler
{
public:
  sphResult GetDesc(sphSamplerDesc * desc) override;
private:
  SamplerImpl();
  ~SamplerImpl();
};

class RenderPassImpl : public TObj<VkRenderPass, ISPHRenderPass>
{
  using This = TObj<VkRenderPass, ISPHRenderPass>;
public:
private:
  RenderPassImpl(DeviceImpl* pDevice, const sphRenderPassDesc* pDesc);
  ~RenderPassImpl();
  DeviceImpl* Device = nullptr;
  VkRenderPassCreateInfo CachedCreateInfo = { VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO };
  VkFramebufferCreateInfo FramebufferCreateInfo = { VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO };
  VkFramebuffer Framebuffer = VK_NULL_HANDLE;
};

extern API ISPHFactory * CreateFactory();
} // namespace vulkan