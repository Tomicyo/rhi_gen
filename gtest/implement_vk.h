/**
This header was generated by `rhi_gen` (https://github.com/Tomicyo/rhi_gen)
Copyright (c) 2017 Tsin Studio

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
**/
#include "sappheiros.h"
#include <vulkan/vulkan.h>

namespace vulkan
{

template <typename T, typename Interface>
class TObj : public Interface
{
public:

  TObj()
    : internalCount(1)
    , externalCount(1)
    , handle(nullptr)
  {
  }

  virtual ~TObj() {}

  uint32_t AddRef() override
  {
    internalCount++;
    externalCount++;
    return internalCount;
  }

  uint32_t Release() override
  {
    internalCount--;
    externalCount--;
    int refCount = internalCount;
    if (internalCount == 0)
    {
      delete this; // will free ref counter
    }
    return refCount;
  }

private:
  uint32_t internalCount;
  uint32_t externalCount;
protected:
  T handle;
};

class FactoryImpl : public TObj<VkInstance, ISPHFactory>
{
public:
  using This = TObj<VkInstance, ISPHFactory>;
  sphResult EnumDevice(uint32_t * count, ISPHDevice ** ppDevice) override;
  sphResult CreateSwapchain(const sphSwapChainDesc * desc, ISPHCommandQueue * pCommandQueue, void * pWindow, ISPHSwapChain ** pSwapchain) override;
private:
  friend ISPHFactory * CreateFactory();
  FactoryImpl();
  ~FactoryImpl();
};

class SwapChainImpl : public TObj<VkSwapchainKHR, ISPHSwapChain>
{
public:
  void Present() override;
private:
  friend class FactoryImpl;
  SwapChainImpl(FactoryImpl* impl);
  ~SwapChainImpl();
  FactoryImpl * mImpl;
};

class DeviceImpl : public TObj<VkDevice, ISPHDevice>
{
public:
  using This = TObj<VkDevice, ISPHDevice>;
  void GetDesc(sphDeviceDesc * pDesc) override;
  sphResult CreateCommandQueue(sphCommandQueueType queueType, ISPHCommandQueue ** pQueue) override;
  sphResult CreatePipelineLayout(ISPHPipelineLayout ** ppPipelineLayout) override;
  sphResult CreatePipelineState(const sphPipelineStateDesc * pPipelineDesc, ISPHPipelineState ** pPipelineState) override;
  sphResult CreateRenderPass() override;
  sphResult CreateRenderTarget() override;
  sphResult CreateSampler(const sphSamplerDesc* desc, ISPHSampler ** pSampler) override;
  sphResult CreateBuffer(const sphBufferDesc* desc, ISPHBuffer ** pBuffer) override;
  sphResult CreateBufferView(const sphBufferViewDesc * desc, ISPHBuffer * pBuffer, ISPHBufferView ** pBufView) override;
  sphResult CreateTexture(const sphTextureDesc * desc, ISPHTexture ** pTexture) override;
  sphResult CreateTextureView(const sphTextureViewDesc * desc, ISPHTexture * pTexture, ISPHTextureView ** pTexView) override;
  void WaitIdle() override;
private:
  friend class FactoryImpl;
  DeviceImpl(FactoryImpl* impl, VkPhysicalDevice Device);
  ~DeviceImpl();
  VkPhysicalDevice mGpu;
  VkPhysicalDeviceProperties props = {};
  FactoryImpl * mImpl;
};

class CommandQueueImpl : public ISPHCommandQueue
{
public:
  ISPHCommandBuffer * CommandBuffer() override;
private:
  CommandQueueImpl();
  ~CommandQueueImpl();
};

class CommandBufferImpl : public ISPHCommandBuffer
{
public:
  void Commit() override;
  void Present(ISPHSwapChain * pSwapChain) override;
  void CopyTexture() override;
  void CopyBuffer() override;
  void ClearColorDepth() override;
  void Begin() override;
  void BeginRenderPass(const ISPHRenderPass* pRenderPass) override;
  void SetScissorRects() override;
  void SetViewport(const sphViewport * pViewport) override;
  void SetPipelineState(ISPHPipelineState* pPipelineState) override;
  void SetPipelineLayout(ISPHPipelineLayout * pPipelineLayout) override;
  void SetBindingGroup(ISPHBindingGroup * pBindingGroup) override;
  void SetIndexBuffer() override;
  void SetVertexBuffer(uint32_t slot, uint64_t offset, ISPHBuffer * pVertexBuffer) override;
  void SetPrimitiveType(sphPrimitiveType primitive) override;
  void DrawInstanced(const sphDrawInstancedDesc * drawParam) override;
  void DrawIndexedInstanced(const sphDrawIndexedInstancedDesc * drawParam) override;
  void EndRenderPass() override;
  void End() override;
  void Dispatch(uint32_t x, uint32_t y, uint32_t z) override;
  void ExecuteBundle() override;
private:
  CommandBufferImpl();
  ~CommandBufferImpl();
};

class PipelineStateImpl : public ISPHPipelineState
{
public:
  sphPipelineType Type() override;
  sphResult GetDesc(sphPipelineStateDesc * desc) override;
private:
  PipelineStateImpl();
  ~PipelineStateImpl();
};

class PipelineLayoutImpl : public ISPHPipelineLayout
{
public:
private:
  PipelineLayoutImpl();
  ~PipelineLayoutImpl();
};

class BindingGroupImpl : public ISPHBindingGroup
{
public:
  void SetSampler(uint32_t index, sphShaderType shaderVis, ISPHSampler * pSampler) override;
  void SetBuffer(uint32_t index, sphShaderType shaderVis, ISPHBufferView * bufferView) override;
  void SetTexture(uint32_t index, sphShaderType shaderVis, ISPHTextureView * textureView) override;
private:
  BindingGroupImpl();
  ~BindingGroupImpl();
};

class BufferImpl : public ISPHBuffer
{
public:
  sphResult GetDesc(sphBufferDesc * pDesc) override;
private:
  BufferImpl();
  ~BufferImpl();
};

class TextureImpl : public ISPHTexture
{
public:
  sphResult GetDesc(sphTextureDesc * pDesc) override;
private:
  TextureImpl();
  ~TextureImpl();
};

class SamplerImpl : public ISPHSampler
{
public:
  sphResult GetDesc(sphSamplerDesc * desc) override;
private:
  SamplerImpl();
  ~SamplerImpl();
};

class RenderPassImpl : public ISPHRenderPass
{
public:
private:
  RenderPassImpl();
  ~RenderPassImpl();
};

ISPHFactory * CreateFactory();
} // namespace vulkan