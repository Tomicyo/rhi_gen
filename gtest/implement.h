/**
This header was generated by `rhi_gen` (https://github.com/Tomicyo/rhi_gen)
Copyright (c) 2017 Tsin Studio

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
**/
#include "interface.h"
#include <vulkan/vulkan.h>

namespace vulkan
{

template <typename T, typename Interface>
class TObj : public Interface
{
public:

  TObj()
    : internalCount(1)
    , externalCount(1)
    , handle(nullptr)
  {
  }

  virtual ~TObj() {}

  uint32_t AddRef() override
  {
    internalCount++;
    externalCount++;
    return internalCount;
  }

  uint32_t Release() override
  {
    internalCount--;
    externalCount--;
    int refCount = internalCount;
    if (internalCount == 0)
    {
      delete this; // will free ref counter
    }
    return refCount;
  }

private:
  uint32_t internalCount;
  uint32_t externalCount;
protected:
  T handle;
};

class FactoryImpl : public TObj<VkInstance, INXTFactory>
{
public:
  using This = TObj<VkInstance, INXTFactory>;
  nxtResult EnumDevice(uint32_t * count, INXTDevice ** ppDevice) override;
  nxtResult CreateSwapchain(nxtSwapChainDesc * desc, void * pWindow, INXTSwapChain ** pSwapchain) override;
private:
  friend INXTFactory * CreateFactory();
  FactoryImpl();
  ~FactoryImpl();
};

class SwapChainImpl : public TObj<VkSwapchainKHR, INXTSwapChain>
{
public:
  void Present() override;
private:
  friend class FactoryImpl;
  SwapChainImpl(FactoryImpl* impl);
  ~SwapChainImpl();
  FactoryImpl * mImpl;
};

class DeviceImpl : public TObj<VkDevice, INXTDevice>
{
public:
  using This = TObj<VkDevice, INXTDevice>;
  void GetDesc(nxtDeviceDesc * pDesc) override;
  nxtResult CreateCommandQueue(nxtCommandQueueType queueType, INXTCommandQueue ** pQueue) override;
  nxtResult CreatePipelineLayout(INXTPipelineLayout ** ppPipelineLayout) override;
  nxtResult CreatePipelineState(const nxtPipelineStateDesc * pPipelineDesc, INXTPipelineState ** pPipelineState) override;
  nxtResult CreateRenderPass() override;
  nxtResult CreateRenderTarget() override;
  nxtResult CreateSampler(const nxtSamplerDesc* desc, INXTSampler ** pSampler) override;
  nxtResult CreateBuffer(const nxtBufferDesc* desc, INXTBuffer ** pBuffer) override;
  nxtResult CreateBufferView(const nxtBufferViewDesc * desc, INXTBuffer * pBuffer, INXTBufferView ** pBufView) override;
  nxtResult CreateTexture(const nxtTextureDesc * desc, INXTTexture ** pTexture) override;
  nxtResult CreateTextureView(const nxtTextureViewDesc * desc, INXTTexture * pTexture, INXTTextureView ** pTexView) override;
  void WaitIdle() override;
private:
  friend class FactoryImpl;
  DeviceImpl(FactoryImpl* impl, VkPhysicalDevice Device);
  ~DeviceImpl();
  VkPhysicalDevice mGpu;
  VkPhysicalDeviceProperties props = {};
  FactoryImpl * mImpl;
};

class CommandQueueImpl : public INXTCommandQueue
{
public:
  INXTCommandBuffer * CommandBuffer() override;
private:
  CommandQueueImpl();
  ~CommandQueueImpl();
};

class CommandBufferImpl : public INXTCommandBuffer
{
public:
  void Commit() override;
  void Present(INXTSwapChain * pSwapChain) override;
  void CopyTexture() override;
  void CopyBuffer() override;
  void ClearColorDepth() override;
  void Begin() override;
  void BeginRenderPass(const INXTRenderPass* pRenderPass) override;
  void SetScissorRects() override;
  void SetViewport(const nxtViewport * pViewport) override;
  void SetPipelineState(INXTPipelineState* pPipelineState) override;
  void SetPipelineLayout(INXTPipelineLayout * pPipelineLayout) override;
  void SetBindingGroup(INXTBindingGroup * pBindingGroup) override;
  void SetIndexBuffer() override;
  void SetVertexBuffer(uint32_t slot, uint64_t offset, INXTBuffer * pVertexBuffer) override;
  void SetPrimitiveType(nxtPrimitiveType primitive) override;
  void DrawInstanced(const nxtDrawInstancedDesc * drawParam) override;
  void DrawIndexedInstanced(const nxtDrawIndexedInstancedDesc * drawParam) override;
  void EndRenderPass() override;
  void End() override;
  void Dispatch(uint32_t x, uint32_t y, uint32_t z) override;
  void ExecuteBundle() override;
private:
  CommandBufferImpl();
  ~CommandBufferImpl();
};

class PipelineStateImpl : public INXTPipelineState
{
public:
  nxtPipelineType Type() override;
  nxtResult GetDesc(nxtPipelineStateDesc * desc) override;
private:
  PipelineStateImpl();
  ~PipelineStateImpl();
};

class PipelineLayoutImpl : public INXTPipelineLayout
{
public:
private:
  PipelineLayoutImpl();
  ~PipelineLayoutImpl();
};

class BindingGroupImpl : public INXTBindingGroup
{
public:
  void SetSampler(uint32_t index, nxtShaderType shaderVis, INXTSampler * pSampler) override;
  void SetBuffer(uint32_t index, nxtShaderType shaderVis, INXTBufferView * bufferView) override;
  void SetTexture(uint32_t index, nxtShaderType shaderVis, INXTTextureView * textureView) override;
private:
  BindingGroupImpl();
  ~BindingGroupImpl();
};

class BufferImpl : public INXTBuffer
{
public:
  nxtResult GetDesc(nxtBufferDesc * pDesc) override;
private:
  BufferImpl();
  ~BufferImpl();
};

class TextureImpl : public INXTTexture
{
public:
  nxtResult GetDesc(nxtTextureDesc * pDesc) override;
private:
  TextureImpl();
  ~TextureImpl();
};

class SamplerImpl : public INXTSampler
{
public:
  nxtResult GetDesc(nxtSamplerDesc * desc) override;
private:
  SamplerImpl();
  ~SamplerImpl();
};

class RenderPassImpl : public INXTRenderPass
{
public:
private:
  RenderPassImpl();
  ~RenderPassImpl();
};

} // namespace vulkan